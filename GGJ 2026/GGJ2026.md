  好的，我已经收到了你的Unity项目代码。让我先仔细阅读和理解这些代码，然后为你整理一份设计文档。

从代码来看，这是一个**多人联机的2D生存/追逐类游戏**（类似《第五人格》的简化版），使用 **Unity Netcode for GameObjects (NGO)** 进行网络同步。让我逐步分析：

---

## 项目概览

| 属性 | 说明 |
|------|------|
| **项目类型** | 2D多人联机生存追逐游戏 |
| **网络方案** | Unity Netcode for GameObjects (NGO) |
| **游戏模式** | 1名监管者 vs 3名求生者（4人局） |
| **核心机制** | 收集食物得分、阴影隐身、边界限制、倒计时胜负 |

---

## 核心系统架构

### 1. 网络架构

```
┌─────────────────────────────────────────┐
│           NetworkManager                │
│         (Unity NGO 核心)                │
└─────────────────────────────────────────┘
                    │
    ┌───────────────┼───────────────┐
    ▼               ▼               ▼
┌─────────┐   ┌─────────┐     ┌───────────┐
│  Server │   │  Host   │     │  Client   │
│ (专用)  │   │(主机+玩家)│    │ (纯客户端) │
└─────────┘   └─────────┘     └───────────┘
```

**关键网络组件：**
- **NetworkObject**: 所有动态生成对象（玩家、食物）都挂载
- **NetworkVariable**: 状态同步（分数、游戏状态、阴影状态等）
- **ServerRpc/ClientRpc**: 客户端→服务器、服务器→全客户端通信

### 2. 游戏状态机 (GameManager)

```
Lobby(大厅等待) ──4人齐──▶ ReadyCountdown(5秒准备) ──时间到──▶ 
Playing(10分钟游戏) ──时间耗尽/全抓完──▶ 
    ├─▶ CatcherWin(监管者胜)
    └─▶ RunnerWin(求生者胜)
```

**关键设计：**
- 使用 `partial class` 拆分边界管理和倒计时逻辑
- `NetworkVariable<GameState>` 同步所有客户端
- 支持Debug强制开始（跳过准备阶段）

### 3. 阵营与角色系统

| MaskId | 角色 | 阵营 | 特殊能力 |
|--------|------|------|----------|
| 0-2 | 求生者A/B/C | Runner | 可隐身于阴影 |
| 3 | 监管者 | Catcher | 视野正常，游戏开始冻结一段时间 |

**实现方式：**
- `FactionMember` 组件（代码中引用但未提供）管理阵营
- `PlayerImage` 组件通过 `MaskId` 动态切换Sprite和Animator
- **单预制体多角色**：一个Player预制体，根据MaskId显示不同外观

### 4. 核心游戏机制

#### 4.1 阴影隐身系统 (Shadow_Hide)
```csharp
// 核心逻辑
if (目标在阴影中) {
    if (观察者是监管者) 目标完全透明(0)
    else if (观察者是求生者) 目标半透明(0.5)
} else {
    目标完全可见(1)
}
```
- 使用 `NetworkVariable<bool> inShadow` 同步
- 本地计算透明度，平滑过渡

#### 4.2 食物收集系统 (Food + FoodSpawner)
- **FoodSpawner**: 服务器生成，定期补充，边界内随机位置
- **Food**: 触发器检测，ServerRpc处理食用，延迟重生
- 食用后通过 `PlayerScore.AddScoreServerRpc` 加分

#### 4.3 移动与同步 (PlayerMovement)
**双模式支持：**
- **Server Authority**: 客户端发送输入，服务器计算位置（防作弊）
- **Client Authority**: 客户端本地计算，NetworkTransform自动同步（低延迟）

**特性：**
- 障碍物检测（BoxCast分轴检测，支持贴墙滑动）
- 动态速度（根据角色配置）
- 自动镜像翻转（SpriteRenderer.flipX）

---

## 项目结构分析

### 代码文件职责

| 文件 | 职责 | 网络相关 |
|------|------|----------|
| **GameManager** | 游戏状态机、边界管理、胜负判定 | NetworkBehaviour, NetworkVariable |
| **PlayerMovement** | 玩家移动、动画、障碍物检测 | NetworkBehaviour, ServerRpc |
| **PlayerImage** | 角色外观切换（单预制体多角色） | NetworkVariable |
| **PlayerScore** | 积分、玩家名称 | NetworkVariable, ServerRpc |
| **Shadow_Hide** | 阴影隐身、阵营判断 | NetworkVariable, ServerRpc |
| **Food** | 食物逻辑、食用重生 | NetworkBehaviour, ServerRpc |
| **FoodSpawner** | 食物生成、边界内随机位置 | NetworkBehaviour |
| **CameraFollow** | 本地玩家相机跟随 | NetworkBehaviour (IsOwner检查) |
| **SceneLoader** | 网络场景切换 | NetworkBehaviour, ServerRpc |
| **TableMgr** | 配置表管理（Luban方案） | 单例，非网络 |
| **GameExit** | 退出游戏 | MonoBehaviour |

### 缺失的关键组件（代码中引用但未提供）

根据代码引用，以下组件应该存在但文件未上传：
- `FactionMember`: 阵营管理（监管者/求生者）
- `NetworkCountdownTimer`: 倒计时器（需放在NetworkObject上）
- `LobbyManager`: 大厅管理（4人匹配、开始游戏回调）
- `SurvivorState`: 求生者状态（死亡判定）
- `VictoryConditionManager`: 胜利条件管理
- `ScoreboardUI` / `GameOverUI`: UI界面
- `SurvivorScoreProvider` / `GameOverLeaderboardProvider`: 数据提供

---

## 设计亮点

1. **单预制体多角色设计**
   - 通过 `PlayerImage` + `MaskId` 实现4个角色共用1个Player预制体
   - 动态切换AnimatorController和Sprite

2. **灵活的移动授权模式**
   - 同时支持Server Authority和Client Authority
   - 通过 `NetworkTransform.IsServerAuthoritative()` 自动判断

3. **本地视觉计算优化**
   - 阴影透明度完全本地计算，无需网络同步
   - 只同步 `inShadow` bool状态，减少网络流量

4. **分阶段倒计时**
   - 5秒准备阶段（黄色UI）+ 10分钟游戏阶段（白色/红色UI）
   - 支持Debug强制开始

---

## 潜在问题与建议

### 1. 代码结构问题
- **GameManager过于庞大**：使用了 `partial class` 但逻辑仍集中在单个文件，建议拆分为：
  - `GameStateManager`: 状态机
  - `BoundsManager`: 边界管理
  - `CountdownManager`: 倒计时协调

### 2. 网络同步优化
- **PlayerMovement的ServerRpc频繁调用**：每帧发送 `MoveServerRpc`，建议：
  - 增加输入缓冲，降低发送频率（如每秒10-20次）
  - 或使用Client Authority模式减少服务器压力

### 3. 食物系统
- **Food.FindObjectsOfType<Food>()性能问题**：每次生成食物都全场景查找，建议：
  - 使用 `NetworkList` 或 `List<Food>` 缓存引用
  - 或食物重生时直接 `GetComponent<FoodSpawner>` 通知

### 4. 缺失的健壮性检查
- 多处 `FindObjectOfType` 调用，建议改为依赖注入或单例模式
- `GameManager.Instance` 单例模式与NetworkBehaviour混合，需注意生命周期

---

## 下一步

请继续发送以下文件，我可以进一步完善设计文档：
1. **FactionMember.cs** - 阵营管理
2. **LobbyManager.cs** - 大厅匹配逻辑
3. **NetworkCountdownTimer.cs** - 倒计时实现
4. **任何UI相关脚本**（ScoreboardUI, GameOverUI等）
5. **项目目录结构截图**或**场景文件说明**

或者你可以告诉我：
- 这个项目的**名字/主题**是什么？
- **目标平台**（PC/手机/其他）？
- 目前**开发阶段**（原型/开发中/即将完成）？
- 有没有**特定的技术难点**需要重点设计？